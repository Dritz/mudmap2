/*  MUD Map (v2) - A tool to create and organize maps for text-based games
 *  Copyright (C) 2016  Neop (email: mneop@web.de)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/**
 * This class uses html and javascript code by gaardian.com for map visualization
 * While MUD Map is licensed under GPL v3 the visualization
 * code and any exported html files are bound to the following license:
 *
 *     COPYRIGHT INFORMATION.
 *
 *   The Mid'Gaardian Publishing Group encourages a community of sharing,
 *   so the Gaardian Map Archives code is copyleft, with some restrictions:
 *   you are free to reproduce, adapt to your own purposes, or otherwise
 *   distribute the source code behind the Gaardian Map Archives as long as
 *   any resulting copies or adapted versions are also bounded by the same
 *   copyleft licensing scheme.
 *
 *   As a common courtesy to your fellow mappers, you are required to give
 *   credit to any maps themselves (as opposed to the source code)
 *   that you did not create.
 *
 *   This license in its entirety can be seen at http://maps.gaardian.com
 */
package mudmap2.backend.html;

import java.awt.Color;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import mudmap2.backend.Layer;
import mudmap2.backend.Path;
import mudmap2.backend.Place;

/**
 *
 * @author neop
 */
public class GaardianMap {

    // Export world to html file
    public static void writeFile(String filestr, Layer layer){
        File file = new File(filestr);
        file.getParentFile().mkdirs();
        try {
            // get map code from resources
            List<String> linesTop = readRessource("resources/gaardian/map_top.html");
            List<String> linesBody = readRessource("resources/gaardian/map_body.html");
            List<String> linesBottom = readRessource("resources/gaardian/map_bottom.html");
            List<String> linescss = readRessource("resources/gaardian/maps.css");

            PrintWriter outstream = new PrintWriter(new BufferedWriter(new FileWriter(file)));

            // write top lines
            for(String str: linesTop){
                // replace css link with actual css code
                if(str.contains("stylesheet") && str.contains("maps.css")){
                    outstream.println("<style>");
                    for(String str2: linescss) outstream.println(str2);
                    outstream.println("</style>");
                } else {
                    outstream.println(str);
                }
            }

            // write map header
            outstream.write("<div class=\"top-strip\" id=\"top-strip\">");
            outstream.write("<div class=\"header\">" + layer.getWorld().getName() + "</div>");
            outstream.write("Map code by <a href=\"http://maps.gaardian.com/\">Gaardian.com</a>, map generated by <a href=\"https://github.com/Neop/mudmap2\">MUD Map 2</a>");
            outstream.write("</div>");

            // write body lines
            for(String str: linesBody){
                outstream.println(str);
            }

            // write places, paths etc
            outstream.println();
            writeMapDefinition(outstream, layer);
            outstream.println();

            // write bottom lines
            for(String str: linesBottom){
                outstream.println(str);
            }

            outstream.flush();

        } catch (IOException ex) {
            Logger.getLogger(GaardianMap.class.getName()).log(Level.SEVERE, null, ex);
        }

    }

    private static List<String> readRessource(String ressource){
        ClassLoader classLoader = GaardianMap.class.getClassLoader();
        InputStream stream = classLoader.getResourceAsStream(ressource);
        BufferedReader reader = new BufferedReader(new InputStreamReader(stream));
        List<String> lines = new ArrayList<String>();
        String line;
        try {
            while((line = reader.readLine()) != null) lines.add(line);
        } catch (IOException ex) {
            Logger.getLogger(GaardianMap.class.getName()).log(Level.SEVERE, null, ex);
            return lines;
        }
        return lines;
    }

    private static int translateExitDir(String dir){
        int ret = -1;
        if(dir.equals("n")) ret = 0;
        else if(dir.equals("ne")) ret = 4;
        else if(dir.equals("e")) ret = 1;
        else if(dir.equals("se")) ret = 5;
        else if(dir.equals("s")) ret = 2;
        else if(dir.equals("sw")) ret = 5;
        else if(dir.equals("w")) ret = 3;
        else if(dir.equals("nw")) ret = 4;
        else if(dir.equals("u")) ret = 4;
        else if(dir.equals("d")) ret = 5;
        return ret;
    }

    private static void writeMapDefinition(PrintWriter outstream, Layer layer) {
        // map ids (internal -> export)
        HashMap<Integer, Integer> placeIds = new HashMap<Integer, Integer>();
        int maxPlaceId = 0;

        int xMin = layer.getXMin();
        int xMax = layer.getXMax();
        int yMin = layer.getYMin();
        int yMax = layer.getYMax();

        // export rooms
        for(Place place: layer.getPlaces()){
            placeIds.put(place.getId(), ++maxPlaceId);

            Boolean isEntrance = false;
            for(Place parent: place.getParents()){
                // place is an entrance if one of the parent places is on another layer
                if(parent.getLayer() != place.getLayer()){
                    isEntrance = true;
                    break;
                }
            }
            if(!isEntrance){
                for(Place child: place.getChildren()){
                    // place is an entrance if one of the parent places is on another layer
                    if(child.getLayer() != place.getLayer()){
                        isEntrance = true;
                        break;
                    }
                }
            }

            // TODO: export colors
            int aggroType = 0;
            /* value 1: moving aggressive
             * value > 1
             * color red
             */

            String hexColor = "";
            if(place.getArea() != null){
                Color areaCol = place.getArea().getColor();
                    hexColor = String.format("#%02x%02x%02x",
                            areaCol.getRed(), areaCol.getGreen(), areaCol.getBlue());
            }

            outstream.println("rooms[" + maxPlaceId + "] = "
                    + "new Room(" + maxPlaceId + ", \""
                    + place.getName() + "\", "
                    + (place.getX() - xMin + 1) + ", "
                    + (yMax - (place.getY() - 1)) + ", "
                    + isEntrance + ", " + aggroType
                    + ", false, false, '"
                    + hexColor + "', null);");
        }

        outstream.println();

        // export paths/exits
        for(Place place: layer.getPlaces()){
            int placeId = placeIds.get(place.getId());

            HashSet<Path> paths = place.getPaths();
            if(paths.isEmpty()){
                outstream.println("rooms[" + placeId + "].exitsArray = new Array();");
            } else {
                outstream.print("rooms[" + placeId + "].exitsArray = [");

                for(Path path: paths){
                    Place other = path.getOtherPlace(place);
                    String exit = path.getExit(place);

                    if(placeIds.containsKey(other.getId())){
                        int exitType = translateExitDir(exit);
                        String exitAction = "";
                        String areaExit = "null";

                        Boolean isCardinalDir = Path.isCardinalDir(exit);
                        String doorInfo = "new DoorInfo(\""
                                + (isCardinalDir ? "" : exit)
                                + "\", 0 , \"\", \"\", null)";

                        outstream.print("new RoomExit("
                                + "rooms[" + placeId + "], "
                                + "rooms[" + placeIds.get(other.getId()) + "], "
                                + "LINK_ONEWAY, "
                                + exitType + ", \""
                                + exitAction + "\", false, "
                                + areaExit + ", "
                                + doorInfo + "),");
                    }
                }

                outstream.println("]");
            }
        }

        outstream.println();
        outstream.println("var gridmaxx = " + (xMax - xMin + 1)
                + ", gridmaxy = " + (yMax - yMin + 1) + ";");
    }
}